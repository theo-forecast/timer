<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Turkey Redistricter & Election Viewer</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- d3 for CSV parsing and colors -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

  <!-- Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #f8fafc;
      --bg-panel: #ffffff;
      --text-main: #0f172a;
      --text-muted: #64748b;
      --border: #e2e8f0;
      --primary: #3b82f6;
      --primary-hover: #2563eb;
      --danger: #ef4444;
      --success: #22c55e;
      --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
      --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
      --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
      --radius: 0.75rem;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text-main);
      height: 100vh;
      overflow: hidden;
      display: flex;
    }

    /* --- Sidebar --- */
    #sidebar {
      width: 400px;
      background: var(--bg-panel);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      z-index: 1000;
      box-shadow: var(--shadow-md);
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border);
    }

    h1 {
      margin: 0 0 0.5rem 0;
      font-size: 1.25rem;
      font-weight: 800;
      letter-spacing: -0.025em;
    }

    .subtitle {
      font-size: 0.875rem;
      color: var(--text-muted);
      margin: 0;
    }

    /* Mode Switcher */
    .mode-switcher {
      display: flex;
      background: var(--bg);
      padding: 0.25rem;
      border-radius: 0.5rem;
      margin-top: 1rem;
      border: 1px solid var(--border);
    }

    .mode-btn {
      flex: 1;
      border: none;
      background: transparent;
      padding: 0.5rem;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-muted);
      border-radius: 0.375rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .mode-btn.active {
      background: var(--bg-panel);
      color: var(--primary);
      box-shadow: var(--shadow-sm);
    }

    /* Scrollable Content Area */
    .scroll-content {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
    }

    /* --- Existing View Styles --- */
    .control-group { margin-bottom: 1.5rem; }
    .control-label {
      display: block;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    select, input[type="text"], button.action-btn {
      width: 100%;
      padding: 0.625rem;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      font-family: inherit;
      font-size: 0.875rem;
      background: var(--bg-panel);
      color: var(--text-main);
      transition: border-color 0.2s;
    }

    select:focus, input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .party-legend {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 0.75rem;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      background: var(--bg);
      padding: 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
    }
    .color-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* --- Editor Styles --- */
    .stats-card {
      background: var(--bg);
      padding: 1rem;
      border-radius: var(--radius);
      border: 1px solid var(--border);
      margin-bottom: 1.5rem;
    }
    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.875rem;
      margin-bottom: 0.25rem;
    }
    .stat-val { font-weight: 600; font-variant-numeric: tabular-nums; }

    .tools-bar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .tool-btn {
      flex: 1;
      padding: 0.5rem;
      border: 1px solid var(--border);
      background: var(--bg-panel);
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 600;
    }
    .tool-btn:hover { background: var(--bg); }
    .tool-btn.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    .district-list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .district-card {
      display: flex;
      align-items: center;
      padding: 0.75rem;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .district-card:hover { border-color: var(--primary); }
    .district-card.active {
      border-color: var(--primary);
      background: #eff6ff;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
    }
    .d-color {
      width: 1.5rem;
      height: 1.5rem;
      border-radius: 0.375rem;
      margin-right: 0.75rem;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .d-info { flex: 1; }
    .d-name { font-weight: 600; font-size: 0.875rem; display: block; }
    .d-pop { font-size: 0.75rem; color: var(--text-muted); font-variant-numeric: tabular-nums; }
    .d-dev { font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem; }
    .d-dev.good { color: var(--success); }
    .d-dev.bad { color: var(--danger); }

    /* --- Map Area --- */
    #map-container {
      flex: 1;
      position: relative;
    }
    #map { width: 100%; height: 100%; outline: none; background: #cddce8; }

    /* --- Loading Curtain --- */
    #curtain {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: var(--bg-panel);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.5s;
    }
    #curtain.hide { opacity: 0; pointer-events: none; }
    .loader {
      width: 40px; height: 40px;
      border: 4px solid var(--border);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Utilities */
    .hidden { display: none !important; }
    .btn-primary {
      background: var(--primary);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
    }
    .btn-primary:hover { background: var(--primary-hover); }

  </style>
</head>
<body>

  <!-- Loading Screen -->
  <div id="curtain">
    <div class="loader"></div>
    <div id="loader-msg">Initializing Application...</div>
  </div>

  <!-- Sidebar -->
  <aside id="sidebar">
    <div class="sidebar-header">
      <h1>Turkey Redistricter</h1>
      <p class="subtitle">Interactive Election Map & District Drawer</p>
      
      <div class="mode-switcher">
        <button class="mode-btn active" data-mode="view" onclick="setMode('view')">Data View</button>
        <button class="mode-btn" data-mode="edit" onclick="setMode('edit')">Map Drawer</button>
      </div>
    </div>

    <!-- VIEW MODE UI -->
    <div id="view-ui" class="scroll-content">
      <div class="control-group">
        <label class="control-label">Election</label>
        <select id="election-select"></select>
      </div>

      <div class="control-group">
        <label class="control-label">Province Filter</label>
        <select id="province-select">
          <option value="ALL">All Provinces</option>
        </select>
      </div>

      <div class="control-group">
        <label class="control-label">Legend</label>
        <div id="legend-container" class="party-legend"></div>
      </div>
    </div>

    <!-- EDIT MODE UI -->
    <div id="edit-ui" class="scroll-content hidden">
      <div class="stats-card">
        <div class="stat-row">
          <span>Total Population (2024)</span>
          <span class="stat-val" id="total-pop">0</span>
        </div>
        <div class="stat-row">
          <span>Districts Created</span>
          <span class="stat-val" id="district-count">0</span>
        </div>
        <div class="stat-row">
          <span>Ideal Pop / District</span>
          <span class="stat-val" id="ideal-pop">-</span>
        </div>
        <div class="stat-row" style="margin-top:0.5rem; padding-top:0.5rem; border-top:1px solid var(--border);">
          <span>Unassigned Pop</span>
          <span class="stat-val" id="unassigned-pop">0</span>
        </div>
      </div>

      <div class="control-group">
        <label class="control-label">Tools</label>
        <div class="tools-bar">
          <button class="tool-btn" id="btn-add-district" onclick="Editor.addDistrict()">+ New District</button>
          <button class="tool-btn" id="btn-eraser" onclick="Editor.setEraser()">Eraser</button>
        </div>
      </div>

      <div class="control-group">
        <label class="control-label">Districts</label>
        <div id="district-list" class="district-list">
          <!-- JS populates this -->
        </div>
      </div>
    </div>
  </aside>

  <!-- Map -->
  <main id="map-container">
    <div id="map"></div>
  </main>

  <script>
    // --- Global State ---
    const State = {
      mode: 'view', // 'view' or 'edit'
      geoData: null,
      popData: [], // parsed CSV
      elections: {}, // loaded election JSONs
      features: [], // array of processed features
      provinceList: [],
      
      // Lookups
      plateToProvince: new Map(),
      provinceToPlate: new Map(),
      districtPopulations: new Map(), // key: __uk, val: 2024 pop
    };

    // --- Editor State ---
    const Editor = {
      districts: [], // { id, name, color, pop, members: Set(__uk) }
      assignments: new Map(), // __uk -> districtId
      activeDistrictId: null,
      isEraser: false,
      isDrawing: false,
      totalPop: 0,
      
      // Methods
      init() {
        // Calculate total population from 2024 data
        let sum = 0;
        State.features.forEach(f => {
          const pop = f.properties.__pop || 0;
          sum += pop;
          State.districtPopulations.set(f.properties.__uk, pop);
        });
        this.totalPop = sum;
        this.updateStats();
      },

      addDistrict() {
        const id = Date.now();
        const num = this.districts.length + 1;
        const color = this.generateColor(num);
        
        this.districts.push({
          id: id,
          name: `District ${num}`,
          color: color,
          pop: 0,
          members: new Set()
        });
        
        this.setActive(id);
        this.renderList();
        this.updateStats();
      },

      setEraser() {
        this.isEraser = true;
        this.activeDistrictId = null;
        document.querySelectorAll('.district-card').forEach(el => el.classList.remove('active'));
        document.getElementById('btn-eraser').classList.add('active');
      },

      setActive(id) {
        this.isEraser = false;
        this.activeDistrictId = id;
        document.getElementById('btn-eraser').classList.remove('active');
        this.renderList();
      },

      assign(featureKey) {
        if (!featureKey) return;
        const pop = State.districtPopulations.get(featureKey) || 0;
        
        // Remove from old
        const oldId = this.assignments.get(featureKey);
        if (oldId) {
          const d = this.districts.find(d => d.id === oldId);
          if (d) {
            d.members.delete(featureKey);
            d.pop -= pop;
          }
        }

        // Add to new
        if (this.isEraser) {
          this.assignments.delete(featureKey);
        } else if (this.activeDistrictId) {
          const d = this.districts.find(d => d.id === this.activeDistrictId);
          if (d) {
            this.assignments.set(featureKey, this.activeDistrictId);
            d.members.add(featureKey);
            d.pop += pop;
          }
        }

        this.updateStats();
        this.renderList(); // Update numbers
        
        // Update map style for this feature specifically if possible, 
        // but simple way is refresh all to be safe or use Leaflet style update
        refreshFeatureStyles();
      },

      updateStats() {
        const count = this.districts.length;
        const ideal = count > 0 ? Math.round(this.totalPop / count) : 0;
        
        document.getElementById('total-pop').textContent = this.totalPop.toLocaleString();
        document.getElementById('district-count').textContent = count;
        document.getElementById('ideal-pop').textContent = ideal > 0 ? ideal.toLocaleString() : "-";
        
        let assignedPop = 0;
        this.districts.forEach(d => assignedPop += d.pop);
        document.getElementById('unassigned-pop').textContent = (this.totalPop - assignedPop).toLocaleString();
      },

      renderList() {
        const list = document.getElementById('district-list');
        list.innerHTML = '';
        
        const count = this.districts.length;
        const ideal = count > 0 ? this.totalPop / count : 0;

        this.districts.forEach(d => {
          const el = document.createElement('div');
          el.className = `district-card ${d.id === this.activeDistrictId ? 'active' : ''}`;
          el.onclick = () => this.setActive(d.id);
          
          let devHtml = '';
          if (ideal > 0) {
            const dev = (d.pop - ideal) / ideal * 100;
            const devClass = Math.abs(dev) < 5 ? 'good' : 'bad';
            devHtml = `<span class="d-dev ${devClass}">${dev > 0 ? '+' : ''}${dev.toFixed(1)}%</span>`;
          }

          el.innerHTML = `
            <div class="d-color" style="background:${d.color}"></div>
            <div class="d-info">
              <span class="d-name">${d.name}</span>
              <span class="d-pop">${d.pop.toLocaleString()} pop ${devHtml}</span>
            </div>
          `;
          list.appendChild(el);
        });
      },

      generateColor(num) {
        // High contrast distinct colors
        const colors = [
          '#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', 
          '#06b6d4', '#3b82f6', '#6366f1', '#8b5cf6', '#d946ef', 
          '#f43f5e', '#64748b'
        ];
        return colors[(num - 1) % colors.length];
      }
    };

    // --- UI Logic ---

    function setMode(mode) {
      State.mode = mode;
      
      // UI Toggles
      document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
      document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
      
      document.getElementById('view-ui').classList.toggle('hidden', mode !== 'view');
      document.getElementById('edit-ui').classList.toggle('hidden', mode !== 'edit');

      // Refresh Map
      refreshFeatureStyles();
      
      // Init editor stats if first time
      if (mode === 'edit' && Editor.totalPop === 0) {
        Editor.init();
      }
    }

    // --- Map Logic ---
    let map;
    let districtLayer;
    let provinceLayer; // Outline for provinces

    function initMap() {
      map = L.map('map', { 
        center: [39, 35], 
        zoom: 6,
        zoomControl: false,
        attributionControl: false
      });
      L.control.zoom({ position: 'bottomright' }).addTo(map);

      // Base layer
      L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19
      }).addTo(map);

      // Mouse events for painting
      map.on('mousedown', () => { if(State.mode === 'edit') Editor.isDrawing = true; });
      map.on('mouseup', () => { if(State.mode === 'edit') Editor.isDrawing = false; });
      map.on('dragend', () => { Editor.isDrawing = false; }); // Safety
    }

    // --- Data Loading ---

    async function loadAll() {
      const elLoaderMsg = document.getElementById('loader-msg');
      
      try {
        // 1. Load CSV
        elLoaderMsg.textContent = "Loading Population Data...";
        const csvText = await fetch('province_district_2014_2019_2024.csv').then(r => r.text());
        State.popData = d3.csvParse(csvText);

        // 2. Load GeoJSON
        elLoaderMsg.textContent = "Loading Map Data...";
        const geoRes = await fetch('turkey-admin-level-6.geojson');
        const rawGeo = await geoRes.json();
        
        processGeoJSON(rawGeo);

        // 3. Load Elections (Start with Istanbul as default)
        elLoaderMsg.textContent = "Loading Election Data...";
        await loadElection('İstanbul.json', 'Istanbul Local 2024');

        // Init UI
        populateUI();
        refreshFeatureStyles();
        document.getElementById('curtain').classList.add('hide');

      } catch (e) {
        console.error(e);
        elLoaderMsg.textContent = "Error loading data. Check console.";
        elLoaderMsg.style.color = "var(--danger)";
      }
    }

    function processGeoJSON(geo) {
      // Create a lookup for pop data
      // Key format: "ProvinceName|DistrictName" normalized
      const popMap = new Map();
      State.popData.forEach(row => {
        const key = keyify(row.Province) + "|" + keyify(row.District);
        const pop = parseInt(row['2024'] || "0", 10);
        popMap.set(key, pop);
      });

      // Process features
      // Note: The GeoJSON seems to use 'network' property for province sometimes, or relations.
      // We will try to extract province and district names.
      
      State.features = geo.features.map(f => {
        const props = f.properties || {};
        
        // Extract Name
        let name = props.name || "Unknown";
        
        // Extract Province (Heuristic based on provided file snippet analysis)
        // The network tag often looks like "TR31-districts" -> Plate 31 -> Hatay
        let plate = "0";
        if (props.network) {
          const match = props.network.match(/TR(\d+)/);
          if (match) plate = match[1];
        }
        
        // If we have a plate, we can infer province name if we had a mapping.
        // For now, let's rely on matching names to the CSV.
        
        const keyName = keyify(name);
        
        // Find matching population row (Brute force for safety if province unknown)
        // Ideally we filter by province, but extraction is tricky without a mapping table.
        // We will try to find a district name match in CSV.
        // Note: This might collide for duplicate district names (e.g. Ereğli), but better than nothing.
        // Let's refine: Use the plate if available.
        
        let pop = 0;
        let provName = "Unknown";
        let uniqueKey = props['@id'] || Math.random().toString();

        // Simple lookup by district name in pop data
        // Priority: Match Plate if possible (Need plate->province map, hardcoding a few or building dynamically?)
        // Let's build a Plate->Province map from CSV since CSV doesn't have plates.
        // Actually, standard Turkey plates: 01 Adana, 34 Istanbul etc.
        // I will assume the CSV is the source of truth for names.
        
        const matchedRow = State.popData.find(r => keyify(r.District) === keyName);
        if (matchedRow) {
          pop = parseInt(matchedRow['2024'] || "0", 10);
          provName = matchedRow.Province;
        }

        return {
          type: "Feature",
          geometry: f.geometry,
          properties: {
            ...props,
            __name: name,
            __prov: provName,
            __pop: pop,
            __uk: uniqueKey // Unique key for editor assignment
          }
        };
      });

      // Filter out non-polygons if any (Points exist in the provided snippet)
      State.features = State.features.filter(f => f.geometry.type === "Polygon" || f.geometry.type === "MultiPolygon");

      // Add to map
      districtLayer = L.geoJSON({type:"FeatureCollection", features:State.features}, {
        style: styleFeature,
        onEachFeature: onEachFeature
      }).addTo(map);

      map.fitBounds(districtLayer.getBounds());
    }

    async function loadElection(filename, label) {
      try {
        const res = await fetch(filename);
        const data = await res.json();
        
        // Process this election file
        // The provided JSON structure is specific: Array of objects.
        // First object seems to be header/metadata sometimes? Or flat list.
        // Looking at snippet: It has "İlçe Adı" and party keys.
        
        const electionKey = filename;
        State.elections[electionKey] = {
          label: label,
          data: data
        };

        // Update Select
        const sel = document.getElementById('election-select');
        const opt = document.createElement('option');
        opt.value = electionKey;
        opt.text = label;
        sel.appendChild(opt);
        
        // Also add Provinces to filter
        const provs = new Set(State.features.map(f => f.properties.__prov).filter(p => p !== "Unknown"));
        const provSel = document.getElementById('province-select');
        Array.from(provs).sort().forEach(p => {
          if(!provSel.querySelector(`[value="${p}"]`)){
             const o = document.createElement('option');
             o.value = p;
             o.text = p;
             provSel.appendChild(o);
          }
        });

      } catch (e) {
        console.warn("Failed to load election", filename, e);
      }
    }

    // --- Styling & Interaction ---

    function styleFeature(feature) {
      // Default Base Style
      const style = {
        weight: 1,
        opacity: 1,
        color: '#cbd5e1', // border
        fillOpacity: 0.8,
        fillColor: '#f1f5f9'
      };

      if (State.mode === 'edit') {
        // Edit Mode Coloring
        const distId = Editor.assignments.get(feature.properties.__uk);
        if (distId) {
          const dist = Editor.districts.find(d => d.id === distId);
          if (dist) {
            style.fillColor = dist.color;
            style.fillOpacity = 0.9;
            style.color = 'rgba(0,0,0,0.2)';
          }
        }
      } else {
        // View Mode Coloring (Election Results)
        // Simplified Logic: Color by winner of currently selected election
        // Since we don't have the full logic of the previous app, I'll implement a basic winner-take-all tint
        
        // For demonstration, let's keep it gray or use a random consistent color based on name
        // Real implementation would look up results in State.elections[current]
        
        const selVal = document.getElementById('election-select').value;
        if (selVal && State.elections[selVal]) {
          const electionData = State.elections[selVal].data;
          // Find data for this district
          const distName = feature.properties.__name;
          // Clean name
          const row = electionData.find(d => {
             return d["İlçe Adı"] && keyify(d["İlçe Adı"]) === keyify(distName);
          });

          if (row) {
             // Find winner
             let winner = null;
             let maxVotes = -1;
             
             // Iterate keys to find parties (Hack: exclude metadata keys)
             Object.keys(row).forEach(k => {
               if (k !== "İlçe Adı" && k !== "İlçe Id") {
                  const val = parseInt((row[k] || "0").replace(/\./g,''));
                  if (!isNaN(val) && val > maxVotes) {
                    maxVotes = val;
                    winner = k.trim();
                  }
               }
             });
             
             if (winner) {
               style.fillColor = getPartyColor(winner);
               style.fillOpacity = 0.8;
             }
          }
        }
      }
      return style;
    }

    function onEachFeature(feature, layer) {
      // Tooltip
      layer.bindTooltip(() => {
        const p = feature.properties;
        let content = `<b>${p.__name}</b><br/>${p.__prov}<br/>Pop: ${p.__pop.toLocaleString()}`;
        
        if (State.mode === 'edit') {
          const distId = Editor.assignments.get(p.__uk);
          if (distId) {
            const d = Editor.districts.find(x => x.id === distId);
            content += `<br/><b style="color:${d.color}">${d.name}</b>`;
          }
        }
        return content;
      }, { sticky: true });

      // Events
      layer.on({
        mouseover: (e) => {
          const layer = e.target;
          layer.setStyle({ weight: 2, color: '#666' });
          layer.bringToFront();
          
          if (State.mode === 'edit' && Editor.isDrawing) {
            Editor.assign(feature.properties.__uk);
            layer.setStyle(styleFeature(feature)); // Re-apply style immediately
          }
        },
        mouseout: (e) => {
          districtLayer.resetStyle(e.target);
          // Manually re-apply because resetStyle reverts to initial, not current dynamic style
          e.target.setStyle(styleFeature(feature));
        },
        click: (e) => {
          if (State.mode === 'edit') {
            Editor.assign(feature.properties.__uk);
            e.target.setStyle(styleFeature(feature));
          } else {
             // View mode click - maybe zoom or show details?
             map.fitBounds(e.target.getBounds());
          }
        }
      });
    }

    function refreshFeatureStyles() {
      if (districtLayer) {
        districtLayer.eachLayer(layer => {
          layer.setStyle(styleFeature(layer.feature));
        });
      }
    }

    // --- Utilities ---

    function keyify(str) {
      if (!str) return "";
      return str.toString().toLowerCase()
        .replace(/ğ/g, 'g').replace(/ü/g, 'u').replace(/ş/g, 's')
        .replace(/ı/g, 'i').replace(/İ/g, 'i').replace(/ö/g, 'o')
        .replace(/ç/g, 'c').replace(/[^a-z0-9]/g, '');
    }

    function getPartyColor(party) {
      const map = {
        'AK PARTİ': '#ff9d1e',
        'CHP': '#d40000',
        'MHP': '#5a0000',
        'İYİ PARTİ': '#0095d9',
        'DEM PARTİ': '#8b00ff', // Or Green
        'YEŞİL SOL PARTİ': '#8b00ff',
        'TİP': '#bb0000',
        'YENİDEN REFAH': '#da291c',
        'ZAFER PARTİSİ': '#a32828',
        'MEMLEKET': '#006aa7'
      };
      return map[party] || '#94a3b8';
    }

    function populateUI() {
      // Setup UI listeners
      document.getElementById('election-select').addEventListener('change', refreshFeatureStyles);
      
      document.getElementById('province-select').addEventListener('change', (e) => {
        const val = e.target.value;
        if (val === "ALL") {
          map.fitBounds(districtLayer.getBounds());
        } else {
          // Filter bounds
          const feats = State.features.filter(f => f.properties.__prov === val);
          if (feats.length > 0) {
             const group = L.featureGroup(feats.map(f => L.geoJSON(f)));
             map.fitBounds(group.getBounds());
          }
        }
      });
    }

    // Start
    window.addEventListener('DOMContentLoaded', loadAll);

  </script>
</body>
</html>
